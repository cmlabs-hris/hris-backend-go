package invitation

import (
	"context"
	"fmt"
	"time"

	"github.com/cmlabs-hris/hris-backend-go/internal/config"
	"github.com/cmlabs-hris/hris-backend-go/internal/domain/employee"
	"github.com/cmlabs-hris/hris-backend-go/internal/domain/invitation"
	"github.com/cmlabs-hris/hris-backend-go/internal/domain/notification"
	"github.com/cmlabs-hris/hris-backend-go/internal/domain/user"
	"github.com/cmlabs-hris/hris-backend-go/internal/pkg/database"
	"github.com/cmlabs-hris/hris-backend-go/internal/pkg/email"
	"github.com/cmlabs-hris/hris-backend-go/internal/repository/postgresql"
	"github.com/cmlabs-hris/hris-backend-go/internal/service/file"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
)

type InvitationServiceImpl struct {
	db                  *database.DB
	invitationRepo      invitation.InvitationRepository
	employeeRepo        employee.EmployeeRepository
	userRepo            user.UserRepository
	emailService        email.EmailService
	fileService         file.FileService
	config              config.InvitationConfig
	notificationService notification.Service
}

// NewInvitationService creates a new invitation service instance
func NewInvitationService(
	db *database.DB,
	invitationRepo invitation.InvitationRepository,
	employeeRepo employee.EmployeeRepository,
	userRepo user.UserRepository,
	emailService email.EmailService,
	fileService file.FileService,
	invitationConfig config.InvitationConfig,
	notificationService notification.Service,
) invitation.InvitationService {
	return &InvitationServiceImpl{
		db:                  db,
		invitationRepo:      invitationRepo,
		employeeRepo:        employeeRepo,
		userRepo:            userRepo,
		emailService:        emailService,
		fileService:         fileService,
		config:              invitationConfig,
		notificationService: notificationService,
	}
}

// CreateAndSend implements invitation.InvitationService.
func (s *InvitationServiceImpl) CreateAndSend(ctx context.Context, req invitation.CreateRequest) (invitation.Invitation, error) {
	expiresAt := time.Now().AddDate(0, 0, s.config.ExpiryDays)

	// Default role to "employee" if not specified
	role := req.Role
	if role == "" {
		role = string(user.RoleEmployee)
	}

	inv := invitation.Invitation{
		EmployeeID:          req.EmployeeID,
		CompanyID:           req.CompanyID,
		InvitedByEmployeeID: req.InvitedByEmployeeID,
		Email:               req.Email,
		Role:                role,
		Status:              invitation.StatusPending,
		ExpiresAt:           expiresAt,
	}

	// Create invitation record (token is generated by database DEFAULT uuidv7())
	created, err := s.invitationRepo.Create(ctx, inv)
	if err != nil {
		return invitation.Invitation{}, fmt.Errorf("failed to create invitation: %w", err)
	}

	// Build invitation link
	invitationLink := fmt.Sprintf("%s/invitations/%s", s.config.BaseURL, created.Token)
	expiresAtStr := expiresAt.Format("02 January 2006, 15:04 WIB")

	// Send email (synchronous)
	err = s.emailService.SendInvitation(
		req.Email,
		req.EmployeeName,
		req.InviterName,
		req.CompanyName,
		req.PositionName,
		invitationLink,
		expiresAtStr,
	)
	if err != nil {
		return invitation.Invitation{}, fmt.Errorf("failed to send invitation email: %w", err)
	}

	// Also send push notification if user already has an account
	go s.notifyOnInvitationSent(ctx, req)

	return created, nil
}

// GetByToken implements invitation.InvitationService.
func (s *InvitationServiceImpl) GetByToken(ctx context.Context, token string) (invitation.InvitationDetailResponse, error) {
	inv, err := s.invitationRepo.GetByTokenWithDetails(ctx, token)
	if err != nil {
		return invitation.InvitationDetailResponse{}, err
	}

	if inv.CompanyLogo != nil && *inv.CompanyLogo == "" {
		fullURL, err := s.fileService.GetFileURL(ctx, *inv.CompanyLogo, 0)
		if err != nil {
			return invitation.InvitationDetailResponse{}, fmt.Errorf("failed to get company logo URL: %w", err)
		}
		inv.CompanyLogo = &fullURL
	}
	return invitation.InvitationDetailResponse{
		Token:        inv.Token,
		Email:        inv.Email,
		EmployeeName: inv.EmployeeName,
		CompanyName:  inv.CompanyName,
		CompanyLogo:  inv.CompanyLogo,
		PositionName: inv.PositionName,
		Role:         inv.Role,
		InviterName:  inv.InviterName,
		Status:       string(inv.Status),
		ExpiresAt:    inv.ExpiresAt.Format("2006-01-02 15:04:05"),
		IsExpired:    inv.IsExpired(),
	}, nil
}

// ListMyInvitations implements invitation.InvitationService.
func (s *InvitationServiceImpl) ListMyInvitations(ctx context.Context, userEmail string) ([]invitation.MyInvitationResponse, error) {
	invitations, err := s.invitationRepo.ListPendingByEmail(ctx, userEmail)
	if err != nil {
		return nil, fmt.Errorf("failed to list invitations: %w", err)
	}

	results := make([]invitation.MyInvitationResponse, 0, len(invitations))
	for _, inv := range invitations {

		fmt.Println(*inv.CompanyLogo)
		if inv.CompanyLogo != nil && *inv.CompanyLogo != "" {
			fullURL, err := s.fileService.GetFileURL(ctx, *inv.CompanyLogo, 0)
			if err != nil {
				return []invitation.MyInvitationResponse{}, fmt.Errorf("failed to get company logo URL: %w", err)
			}
			inv.CompanyLogo = &fullURL
		}

		results = append(results, invitation.MyInvitationResponse{
			Token:        inv.Token,
			CompanyName:  inv.CompanyName,
			CompanyLogo:  inv.CompanyLogo,
			PositionName: inv.PositionName,
			InviterName:  inv.InviterName,
			ExpiresAt:    inv.ExpiresAt.Format("2006-01-02 15:04:05"),
			CreatedAt:    inv.CreatedAt.Format("2006-01-02 15:04:05"),
		})
	}

	return results, nil
}

// Accept implements invitation.InvitationService.
func (s *InvitationServiceImpl) Accept(ctx context.Context, token, userID, userEmail string) (invitation.AcceptResponse, error) {
	// Get invitation with details
	inv, err := s.invitationRepo.GetByTokenWithDetails(ctx, token)
	if err != nil {
		return invitation.AcceptResponse{}, err
	}

	// Validate invitation status
	if inv.Status == invitation.StatusAccepted {
		return invitation.AcceptResponse{}, invitation.ErrInvitationAlreadyUsed
	}
	if inv.Status == invitation.StatusRevoked {
		return invitation.AcceptResponse{}, invitation.ErrInvitationRevoked
	}
	if inv.IsExpired() {
		return invitation.AcceptResponse{}, invitation.ErrInvitationExpired
	}

	// Validate email matches
	if userEmail != inv.Email {
		return invitation.AcceptResponse{}, invitation.ErrEmailMismatch
	}

	// Get user to check if already has company
	userData, err := s.userRepo.GetByID(ctx, userID)
	if err != nil {
		return invitation.AcceptResponse{}, fmt.Errorf("failed to get user: %w", err)
	}
	if userData.CompanyID != nil && *userData.CompanyID != "" {
		return invitation.AcceptResponse{}, invitation.ErrUserAlreadyHasCompany
	}

	// Get employee to check if already linked
	emp, err := s.employeeRepo.GetByID(ctx, inv.EmployeeID)
	if err != nil {
		return invitation.AcceptResponse{}, fmt.Errorf("failed to get employee: %w", err)
	}

	if emp.UserID != nil && *emp.UserID != "" {
		return invitation.AcceptResponse{}, invitation.ErrEmployeeAlreadyLinked
	}

	// Transaction: link user to employee, update user company/role, mark invitation accepted
	err = postgresql.WithTransaction(ctx, s.db, func(tx pgx.Tx) error {
		txCtx := context.WithValue(ctx, "tx", tx)

		// 1. Link employee to user
		if err := s.employeeRepo.LinkUser(txCtx, inv.EmployeeID, userID, inv.CompanyID); err != nil {
			return fmt.Errorf("failed to link user to employee: %w", err)
		}

		// 2. Update user's company_id and role (use role from invitation)
		if err := s.userRepo.UpdateCompanyAndRole(txCtx, userID, inv.CompanyID, inv.Role); err != nil {
			return fmt.Errorf("failed to update user: %w", err)
		}

		// 3. Mark invitation as accepted
		if err := s.invitationRepo.MarkAccepted(txCtx, inv.ID); err != nil {
			return fmt.Errorf("failed to mark invitation accepted: %w", err)
		}

		return nil
	})
	if err != nil {
		return invitation.AcceptResponse{}, err
	}

	// Notify managers that a new employee has joined
	go s.notifyManagersOnEmployeeJoined(ctx, inv, emp.FullName)

	return invitation.AcceptResponse{
		Message:     "Invitation accepted successfully",
		CompanyID:   inv.CompanyID,
		CompanyName: inv.CompanyName,
		EmployeeID:  inv.EmployeeID,
	}, nil
}

// Resend implements invitation.InvitationService.
func (s *InvitationServiceImpl) Resend(ctx context.Context, employeeID, companyID string) error {
	// Get pending invitation
	inv, err := s.invitationRepo.GetPendingByEmployeeID(ctx, employeeID, companyID)
	if err != nil {
		return err
	}

	// Generate new token and expiry
	newToken := uuid.Must(uuid.NewV7()).String()
	newExpiresAt := time.Now().AddDate(0, 0, s.config.ExpiryDays)

	// Update token
	if err := s.invitationRepo.UpdateToken(ctx, inv.ID, newToken, newExpiresAt); err != nil {
		return fmt.Errorf("failed to update token: %w", err)
	}

	// Get details for email
	invWithDetails, err := s.invitationRepo.GetByTokenWithDetails(ctx, newToken)
	if err != nil {
		return fmt.Errorf("failed to get invitation details: %w", err)
	}

	// Build invitation link
	invitationLink := fmt.Sprintf("%s/invitations/%s", s.config.BaseURL, newToken)
	expiresAtStr := newExpiresAt.Format("02 January 2006, 15:04 WIB")

	// Send email
	return s.emailService.SendInvitation(
		invWithDetails.Email,
		invWithDetails.EmployeeName,
		invWithDetails.InviterName,
		invWithDetails.CompanyName,
		invWithDetails.PositionName,
		invitationLink,
		expiresAtStr,
	)
}

// Revoke implements invitation.InvitationService.
func (s *InvitationServiceImpl) Revoke(ctx context.Context, employeeID, companyID string) error {
	// Get pending invitation
	inv, err := s.invitationRepo.GetPendingByEmployeeID(ctx, employeeID, companyID)
	if err != nil {
		return err
	}

	// Check if already accepted
	if inv.Status == invitation.StatusAccepted {
		return invitation.ErrCannotRevokeAccepted
	}

	return s.invitationRepo.MarkRevoked(ctx, inv.ID)
}

// ExistsPendingByEmail implements invitation.InvitationService.
func (s *InvitationServiceImpl) ExistsPendingByEmail(ctx context.Context, email, companyID string) (bool, error) {
	return s.invitationRepo.ExistsPendingByEmail(ctx, email, companyID)
}

// notifyOnInvitationSent sends push notification to user if they already have an account
func (s *InvitationServiceImpl) notifyOnInvitationSent(ctx context.Context, req invitation.CreateRequest) {
	if s.notificationService == nil {
		return
	}

	// Try to find user by email
	userData, err := s.userRepo.GetByEmail(ctx, req.Email)
	if err != nil {
		// User doesn't exist yet, they'll get the email
		return
	}

	_ = s.notificationService.QueueNotification(ctx, notification.CreateNotificationRequest{
		CompanyID:   req.CompanyID,
		RecipientID: userData.ID,
		SenderID:    nil,
		Type:        notification.TypeInvitationSent,
		Title:       "Company Invitation",
		Message:     fmt.Sprintf("You have been invited to join %s as %s", req.CompanyName, req.PositionName),
		Data: map[string]interface{}{
			"company_id":    req.CompanyID,
			"company_name":  req.CompanyName,
			"position_name": req.PositionName,
			"employee_id":   req.EmployeeID,
		},
	})
}

// notifyManagersOnEmployeeJoined sends notifications to all managers when a new employee joins
func (s *InvitationServiceImpl) notifyManagersOnEmployeeJoined(ctx context.Context, inv invitation.InvitationWithDetails, employeeName string) {
	if s.notificationService == nil {
		return
	}

	// Get managers of the company
	managers, err := s.employeeRepo.GetManagersByCompanyID(ctx, inv.CompanyID)
	if err != nil {
		return
	}

	for _, manager := range managers {
		if manager.UserID == nil {
			continue
		}

		_ = s.notificationService.QueueNotification(ctx, notification.CreateNotificationRequest{
			CompanyID:   inv.CompanyID,
			RecipientID: *manager.UserID,
			SenderID:    nil,
			Type:        notification.TypeEmployeeJoined,
			Title:       "New Employee Joined",
			Message:     fmt.Sprintf("%s has joined the company as %s", employeeName, inv.PositionName),
			Data: map[string]interface{}{
				"employee_id":   inv.EmployeeID,
				"employee_name": employeeName,
				"position_name": inv.PositionName,
			},
		})
	}
}
